{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hi, I'am Denis Mulyalin Networking and Network Automation enthusiast sharing my thoughts, news and ideas. List of my public projects: TTP TTP_Templates TTR FakeNOS Nornir-Salt Salt-Nornir YANPD N2G PICLE","title":"About"},{"location":"2022-08-21-5-efficient-ways-to-collect-show-commands-output-from-network-devices/","text":"Problem Statement # Getting show commands output from network devices, what can be simpler - login into device, issue show commands, copy output, create text file on a local file system, paste copied output, save file, exit. And after doing 7 steps above, required output happily sits on the hard drive in a convenient spot ready for processing. Above process is certainly doable and likely sounds very familiar to many Network Engineers. However, what if we tasked to collect not 1 or 2 but 5, 10 or 100 commands and need to get them not from 1 or 2 but 2000 devices? That is there above process quickly falls short and the benefit of automation becomes apparent - hand it over to relentless robots running on our computer systems, happily doing any mundane task we throw at them as many times as we need in as big volumes as we want to. With that, let me introduce 5 solutions to the problem of collecting show commands output from network devices using Salt-Nornir proxy minion . 1 - Using nr.cli Inline Commands Arguments # The simplest, exploratory way to get show commands output from network devices with Salt-Nornir is by using nr.cli function supplied with inline commands arguments: salt nrp1 nr.cli \"show clock\" \"show version\" FL=\"ceos1, ceos2\" That should print similar output to the terminal: [root@salt-master /]# salt nrp1 nr.cli \"show clock\" \"show version\" FL=\"ceos1, ceos2\" nrp1: ---------- ceos1: ---------- show clock: Fri Jul 29 19:03:41 2022 Timezone: UTC Clock source: local show version: cEOSLab Hardware version: Serial number: <omitted for brevity> ceos2: ---------- show clock: Fri Jul 29 19:03:41 2022 Timezone: UTC Clock source: local show version: cEOSLab Hardware version: Serial number: <omitted for brevity> Copy and save output to per-host text files on your local file system. This time it took around 2 seconds to collect 2 commands from 2 devices, not bad. To get it one step further, instruct nrp1 proxy minion to save output into the files on the local (in relation to the minion process) file system, ready to be copied over. salt nrp1 nr.cli \"show clock\" \"show version\" FL=\"ceos1, ceos2\" tf=\"my_commands\" Salt-Nornir will save output to /var/salt-nonir/nrp1/files/ folder: [root@salt-master /]# salt nrp1 cmd.run \"ls -l /var/salt-nornir/nrp1/files\" nrp1: total 12 -rw-r--r--. 1 root root 532 Jul 29 17:09 my_commands__29_July_2022_17_09_10__22__ceos2.txt -rw-r--r--. 1 root root 532 Jul 29 17:09 my_commands__29_July_2022_17_09_10__875__ceos1.txt Can copy files from proxy minion or use nr.file function to retrieve output at any time. For example to read file content for ceos1 host only: salt nrp1 nr.file read filegroup=\"my_commands\" FB=ceos1 2 - Source Show Commands From Files # While you certainly can do this: salt nrp1 nr.cli \"show clock\" \"show version\" \"show ip int brief\" \"show ntp\" \"show lldp neighbor\" \"show bgp sum\" FL=\"ceos1, ceos2\" tf=\"my_commands\" Its certainly going to take a lot of typing. More efficient way is to save commands into a text file on salt-master machine and request proxy minions to source commands to collect form that file. For example, this is /etc/salt/cli/commands.txt file content: show clock show version show ip int brief show ntp show lldp neighbor show bgp sum And this is how to point proxy minion to that file: salt nrp1 nr.cli commands=\"salt://cli/commands.txt\" FL=\"ceos1, ceos2\" tf=\"my_commands\" Same outcome as before, but less typing and easy to reuse later. 3 - Generate Show Commands From Jinja2 Templates # What if command need to contain per host details like source IP address as in ping or traceroute commands, solution is to use Jinja2 templates: salt nrp1 \"traceroute 192.168.2.4 source {{ host.lo0_ip }}\" FL=\"ceos1, ceos2\" Where host.lo0_ip sourced from host inventory data: hosts: ceos1: data: lo0_ip: 10.0.0.1 ceos2: data: lo0_ip: 10.0.0.2 But what if need to collect different commands output from different device types, Jinja2 conditionals certainly can handle it, here is /etc/salt/cli/conditional_commands.txt file content: {% if \"CORE\" in host.name %} show clock show version {% elif \"eos\" in host.name %} show ip int brief show ntp show lldp neighbor show bgp sum {% endif %} To render above template and run generated commands: salt nrp1 nr.cli commands=\"salt://cli/conditional_commands.txt\" FL=\"ceos1, ceos2\" tf=\"my_commands\" Another use case - what if I need to run commands on a per host basis, do I need to use Jinja2 conditionals as well - yes, can rely on Jinja2 conditional or can supply per-host files with commands. For example, this is the content of /etc/salt/cli/commands_ceos1.txt and /etc/salt/cli/commands_ceos2.txt files respectively: show clock show version and show ip int brief show ntp show lldp neighbor show bgp sum nr.cli supports templating to source commands from different files: salt nrp1 nr.cli commands=\"salt://cli/commands_{{ host.name }}.txt\" 4 - Collecting Commands in a Loop # Troubleshooting network problems often can benefit from collecting show commands output from multiple devices simultaneously. This can be easily accomplished using above tricks. But Salt-Nornir does not stop there allowing to collect show commands output from devices in a loop up to a certain number of times with predefined intervals. This comes in handy when problem is reproducible but only lasts for seconds This is how commands can be run in a loop: salt nrp1 nr.cli \"show clock\" \"show ip route\" repeat=10 repeat_interval=1 table=brief table=brief instructs Salt-Nornir to return nicely formatted text table to make it easier to read through the output. Another feature is capability to stop collecting show commands after certain pattern found in the output. Made up example - you want to collect \"show ip route\" output in a loop but stop if certain route becomes visible in the routing table. salt nrp1 nr.cli \"show ip route\" repeat=100 stop_pattern=\"10.1.2.3/24\" table=brief 5 - Using Different Connection Plugins # Salt-Nornir makes it extremely easy to switch between connection methods making sure you have flexibility to choose what works best for you. For example this is how output can be collected using Netmiko plugin: salt nrp1 nr.cli \"show ip route\" Since Netmiko is a default connection method, no need to specify plugin to use. However, this is how different plugins can be invoked: salt nrp1 nr.cli \"show ip route\" plugin=netmiko salt nrp1 nr.cli \"show ip route\" plugin=napalm salt nrp1 nr.cli \"show ip route\" plugin=scrapli salt nrp1 nr.cli \"show ip route\" plugin=pyats Salt-Nornir nr.cli supports Netmiko, NAPALM, Scrapli and PyATS to communicate with devices using CLI. Connection plugins parameters can be provided using Nornir inventory, refer to documentation examples for more details. Besides using different plugins, nr.cli also support promptless (ps) mechanism to collect output from devices. This mechanism based on Netmiko library but adds several enhancements to make process of collecting big amount of output from network devices more reliable. To use promptless mode specify use_ps=True for Netmiko plugin: salt nrp1 nr.cli \"show ip route\" plugin=netmiko use_ps=True Promptless mode has these features: does not timeout on big chunks of data as long as device keeps transmitting data thanks to using read and absolute timeouts supports device prompt change while collecting show commands output multi line commands can be send to device using nowait=True allows to send commands without waiting for prompt to come back In Conclusion # With above arsenal it should be easier to tackle the task of collecting show commands output from network devices. To automate that process even further, SaltStack supports Python API and REST API, Salt-Nornir inherits those capabilities as well. Hope you enjoyed reading this blog post. For comments and suggestions feel free to open an issue .","title":"5 Efficient Ways to Collect Show Commands Output From Network Devices"},{"location":"2022-08-21-5-efficient-ways-to-collect-show-commands-output-from-network-devices/#problem-statement","text":"Getting show commands output from network devices, what can be simpler - login into device, issue show commands, copy output, create text file on a local file system, paste copied output, save file, exit. And after doing 7 steps above, required output happily sits on the hard drive in a convenient spot ready for processing. Above process is certainly doable and likely sounds very familiar to many Network Engineers. However, what if we tasked to collect not 1 or 2 but 5, 10 or 100 commands and need to get them not from 1 or 2 but 2000 devices? That is there above process quickly falls short and the benefit of automation becomes apparent - hand it over to relentless robots running on our computer systems, happily doing any mundane task we throw at them as many times as we need in as big volumes as we want to. With that, let me introduce 5 solutions to the problem of collecting show commands output from network devices using Salt-Nornir proxy minion .","title":"Problem Statement"},{"location":"2022-08-21-5-efficient-ways-to-collect-show-commands-output-from-network-devices/#1-using-nrcli-inline-commands-arguments","text":"The simplest, exploratory way to get show commands output from network devices with Salt-Nornir is by using nr.cli function supplied with inline commands arguments: salt nrp1 nr.cli \"show clock\" \"show version\" FL=\"ceos1, ceos2\" That should print similar output to the terminal: [root@salt-master /]# salt nrp1 nr.cli \"show clock\" \"show version\" FL=\"ceos1, ceos2\" nrp1: ---------- ceos1: ---------- show clock: Fri Jul 29 19:03:41 2022 Timezone: UTC Clock source: local show version: cEOSLab Hardware version: Serial number: <omitted for brevity> ceos2: ---------- show clock: Fri Jul 29 19:03:41 2022 Timezone: UTC Clock source: local show version: cEOSLab Hardware version: Serial number: <omitted for brevity> Copy and save output to per-host text files on your local file system. This time it took around 2 seconds to collect 2 commands from 2 devices, not bad. To get it one step further, instruct nrp1 proxy minion to save output into the files on the local (in relation to the minion process) file system, ready to be copied over. salt nrp1 nr.cli \"show clock\" \"show version\" FL=\"ceos1, ceos2\" tf=\"my_commands\" Salt-Nornir will save output to /var/salt-nonir/nrp1/files/ folder: [root@salt-master /]# salt nrp1 cmd.run \"ls -l /var/salt-nornir/nrp1/files\" nrp1: total 12 -rw-r--r--. 1 root root 532 Jul 29 17:09 my_commands__29_July_2022_17_09_10__22__ceos2.txt -rw-r--r--. 1 root root 532 Jul 29 17:09 my_commands__29_July_2022_17_09_10__875__ceos1.txt Can copy files from proxy minion or use nr.file function to retrieve output at any time. For example to read file content for ceos1 host only: salt nrp1 nr.file read filegroup=\"my_commands\" FB=ceos1","title":"1 - Using nr.cli Inline Commands Arguments"},{"location":"2022-08-21-5-efficient-ways-to-collect-show-commands-output-from-network-devices/#2-source-show-commands-from-files","text":"While you certainly can do this: salt nrp1 nr.cli \"show clock\" \"show version\" \"show ip int brief\" \"show ntp\" \"show lldp neighbor\" \"show bgp sum\" FL=\"ceos1, ceos2\" tf=\"my_commands\" Its certainly going to take a lot of typing. More efficient way is to save commands into a text file on salt-master machine and request proxy minions to source commands to collect form that file. For example, this is /etc/salt/cli/commands.txt file content: show clock show version show ip int brief show ntp show lldp neighbor show bgp sum And this is how to point proxy minion to that file: salt nrp1 nr.cli commands=\"salt://cli/commands.txt\" FL=\"ceos1, ceos2\" tf=\"my_commands\" Same outcome as before, but less typing and easy to reuse later.","title":"2 - Source Show Commands From Files"},{"location":"2022-08-21-5-efficient-ways-to-collect-show-commands-output-from-network-devices/#3-generate-show-commands-from-jinja2-templates","text":"What if command need to contain per host details like source IP address as in ping or traceroute commands, solution is to use Jinja2 templates: salt nrp1 \"traceroute 192.168.2.4 source {{ host.lo0_ip }}\" FL=\"ceos1, ceos2\" Where host.lo0_ip sourced from host inventory data: hosts: ceos1: data: lo0_ip: 10.0.0.1 ceos2: data: lo0_ip: 10.0.0.2 But what if need to collect different commands output from different device types, Jinja2 conditionals certainly can handle it, here is /etc/salt/cli/conditional_commands.txt file content: {% if \"CORE\" in host.name %} show clock show version {% elif \"eos\" in host.name %} show ip int brief show ntp show lldp neighbor show bgp sum {% endif %} To render above template and run generated commands: salt nrp1 nr.cli commands=\"salt://cli/conditional_commands.txt\" FL=\"ceos1, ceos2\" tf=\"my_commands\" Another use case - what if I need to run commands on a per host basis, do I need to use Jinja2 conditionals as well - yes, can rely on Jinja2 conditional or can supply per-host files with commands. For example, this is the content of /etc/salt/cli/commands_ceos1.txt and /etc/salt/cli/commands_ceos2.txt files respectively: show clock show version and show ip int brief show ntp show lldp neighbor show bgp sum nr.cli supports templating to source commands from different files: salt nrp1 nr.cli commands=\"salt://cli/commands_{{ host.name }}.txt\"","title":"3 - Generate Show Commands From Jinja2 Templates"},{"location":"2022-08-21-5-efficient-ways-to-collect-show-commands-output-from-network-devices/#4-collecting-commands-in-a-loop","text":"Troubleshooting network problems often can benefit from collecting show commands output from multiple devices simultaneously. This can be easily accomplished using above tricks. But Salt-Nornir does not stop there allowing to collect show commands output from devices in a loop up to a certain number of times with predefined intervals. This comes in handy when problem is reproducible but only lasts for seconds This is how commands can be run in a loop: salt nrp1 nr.cli \"show clock\" \"show ip route\" repeat=10 repeat_interval=1 table=brief table=brief instructs Salt-Nornir to return nicely formatted text table to make it easier to read through the output. Another feature is capability to stop collecting show commands after certain pattern found in the output. Made up example - you want to collect \"show ip route\" output in a loop but stop if certain route becomes visible in the routing table. salt nrp1 nr.cli \"show ip route\" repeat=100 stop_pattern=\"10.1.2.3/24\" table=brief","title":"4 - Collecting Commands in a Loop"},{"location":"2022-08-21-5-efficient-ways-to-collect-show-commands-output-from-network-devices/#5-using-different-connection-plugins","text":"Salt-Nornir makes it extremely easy to switch between connection methods making sure you have flexibility to choose what works best for you. For example this is how output can be collected using Netmiko plugin: salt nrp1 nr.cli \"show ip route\" Since Netmiko is a default connection method, no need to specify plugin to use. However, this is how different plugins can be invoked: salt nrp1 nr.cli \"show ip route\" plugin=netmiko salt nrp1 nr.cli \"show ip route\" plugin=napalm salt nrp1 nr.cli \"show ip route\" plugin=scrapli salt nrp1 nr.cli \"show ip route\" plugin=pyats Salt-Nornir nr.cli supports Netmiko, NAPALM, Scrapli and PyATS to communicate with devices using CLI. Connection plugins parameters can be provided using Nornir inventory, refer to documentation examples for more details. Besides using different plugins, nr.cli also support promptless (ps) mechanism to collect output from devices. This mechanism based on Netmiko library but adds several enhancements to make process of collecting big amount of output from network devices more reliable. To use promptless mode specify use_ps=True for Netmiko plugin: salt nrp1 nr.cli \"show ip route\" plugin=netmiko use_ps=True Promptless mode has these features: does not timeout on big chunks of data as long as device keeps transmitting data thanks to using read and absolute timeouts supports device prompt change while collecting show commands output multi line commands can be send to device using nowait=True allows to send commands without waiting for prompt to come back","title":"5 - Using Different Connection Plugins"},{"location":"2022-08-21-5-efficient-ways-to-collect-show-commands-output-from-network-devices/#in-conclusion","text":"With above arsenal it should be easier to tackle the task of collecting show commands output from network devices. To automate that process even further, SaltStack supports Python API and REST API, Salt-Nornir inherits those capabilities as well. Hope you enjoyed reading this blog post. For comments and suggestions feel free to open an issue .","title":"In Conclusion"},{"location":"2023-02-05-templating-network-tests/","text":"Introduction # Templating network devices configuration is a very common approach nowadays, network testing however, is rarely ( if at all) automated. Jinja2 comes to mind when somebody mentions network templates, YAML also pops up as a common way of expressing network related data. SaltStack, Ansible, Nornir and others provide native support for workflows and payload templating using popular templating languages, this however rarely used to automate network tests. The difficulty of doing network testing is due to the lack of structured data that can be easily extracted from network devices. As a result, one of common ways of dealing with network testing is to use show commands output to interpret devices state and operator using that output coupled with expert knowledge decides if system is in a desired state or needs remediation. Luckily, if system created that can use plain text to encode tests content to carry on with testing, that system is very close to templating those steps using data driven approach. Meet Nornir TestsProcessor # In one of my previous blog posts I had a chance to write about the fact that network tests can be classified based one the scope as local (unit), adjacent (integration) and network (system) tests, the focus of this write up is mainly on local and adjacent types of scenarios. This is due to the fact that TestProcessor was created to deal with data produced by a single device only. Original vision behind TestsProcessor was to take a piece of static YAML: - name : Software version test task : show version test : contains pattern : \"17.3.1\" err_msg : Software version is wrong - name : Logging configuration check task : \"show run | inc logging\" test : contains pattern : 10.0.0.1 err_msg : Logging configuration is wrong collect output from network devices and emit tests results: +----+--------+-----------------------------+----------+---------------------------+ | | host | name | result | exception | +====+========+=============================+==========+===========================+ | 0 | R1 | Software version test | FAIL | Software version is wrong | +----+--------+-----------------------------+----------+---------------------------+ | 1 | R1 | Logging configuration check | PASS | | +----+--------+-----------------------------+----------+---------------------------+ Another networking industry common approach is to take data like: HostName: switch1 Vlans: - VlanId: 10 VlanName: MGMT - VlanId: 20 VlanName: ACCESS couple with Jinja2 template: hostname {{ HostName }} ! {% for Vlan in Vlans -%} vlan {{ Vlan['VlanId'] }} name {{ Vlan['VlanName'] }} ! {% endfor -%} and produce network device configuration: hostname switch1 ! vlan 10 name MGMT ! vlan 20 name ACCESS Combining above two approaches lead to conclusion that it should be possible to make TestsProcessor tests suites dynamic, driven entirely by host data. For example, if we have these two Nornir hosts: hosts: jundevice-1: hostname: 10.0.0.1 platform: juniper_junos groups: [\"auth\"] data: software_version: 18.1R3-S9 xrdevice-1: hostname: 10.0.0.2 platform: cisco_xr groups: [\"auth\"] data: software_version: 7.5.2 groups: auth: username: nornir password: nornir it is possible to write Jinja2 template like this: - name: Software version test task: show version test: contains pattern: {{ host.software_version }} err_msg: Software version is wrong producing host specific tests to run to validate device software version. Above idea was implemented in Nornir-Salt starting with release 0.16.0 Scaling Up using Salt-Nornir # Using Nornir to run tests for a handful (hundreds) of devices is great, but doing same for bigger (much bigger) number of devices requires non trivial engineering. Salt-Nornir helps to scale network management using Nornir based proxy minions, each handling multiple devices. Hence, network testing also can be scaled out using Salt-Nornir proxy minions. For example, given the test suite on master at /etc/salt/master/tests/testsuite-1.txt : - task: \"show version\" test: contains pattern: \"{{ host.software_version }}\" name: check ceos version {% for interface in host.interfaces %} - task: \"show interface {{ interface.name }}\" test: contains_lines pattern: - {{ interface.admin_status }} - {{ interface.line_status }} - {{ interface.mtu }} - {{ interface.description }} name: check interface {{ interface.name }} status {% endfor %} coupled with this proxy minion pillar inventory: hosts: ceos1: hostname: 10.0.1.4 platform: arista_eos username: nornir password: nornir data: software_version: cEOS interfaces: - name: Ethernet1 admin_status: is up description: East-West Campus uplink line_status: line protocol is up mtu: IP MTU 9200 - name: Loopback0 admin_status: is up description: RID and MGMT loopback line_status: line protocol is up mtu: IP MTU 1500 tests suite can be run using command: [root@salt-master /]# salt nrp1 nr.test suite=\"salt://tests/testsuite-1.txt\" table=brief nrp1: +----+--------+----------------------------------+----------+-------------+ | | host | name | result | exception | +====+========+==================================+==========+=============+ | 0 | ceos1 | check ceos version | PASS | | +----+--------+----------------------------------+----------+-------------+ | 1 | ceos1 | check interface Ethernet1 status | PASS | | +----+--------+----------------------------------+----------+-------------+ | 2 | ceos1 | check interface Loopback1 status | PASS | | +----+--------+----------------------------------+----------+-------------+ [root@salt-master /]# As you can see, tests content was dynamically rendered according to data stored in host's inventory. Combine this with SaltStack reach data sourcing capabilities and We have a workable solution to test our networks. Adding Netbox into the mix # Netbox is a DCIM/IPAM software to model and document modern networks. Salt-Nornir comes with Netbox Pillar and Netbox Execution Modules, combined, they are capable of sourcing any data from Netbox over REST or GraphQL API right from your templates. Netbox allows to model device interfaces. Example of interfaces modeled in Netbox for ceos1 device: Using Salt-Nornir execution module Netbox get_interfaces functions we can retrieve device interfaces data from Netbox: [root@salt-master /]# salt nrp1 nr.netbox get_interfaces device_name=ceos1 --out=yaml nrp1: Ethernet1: bridge: null bridge_interfaces: [] child_interfaces: [] custom_fields: {} description: East-West Campus uplink duplex: FULL enabled: true last_updated: '2022-12-30T11:21:59.922564+00:00' mac_address: null member_interfaces: [] mode: null mtu: 9200 parent: null speed: null tagged_vlans: [] tags: [] untagged_vlan: null vrf: null wwn: null Loopback0: bridge: null bridge_interfaces: [] child_interfaces: [] custom_fields: {} description: RID and MGMT loopback duplex: null enabled: true last_updated: '2022-12-30T11:22:32.225050+00:00' mac_address: null member_interfaces: [] mode: null mtu: 1500 parent: null speed: null tagged_vlans: [] tags: [] untagged_vlan: null vrf: null wwn: null SaltStack conveniently allows to call execution module functions from within the Jinja2 templates, enabling us to source any data directly during template rendering process. Let use that in this template producing tests suite accordingly: {% set interfaces = salt['nr.netbox']('get_interfaces', 'ceos1') %} {% for interface_name, interface_data in interfaces.items() %} - task: \"show interface {{ interface_name }}\" test: contains_lines pattern: - {{ interface_data.mtu }} - {{ interface_data.description }} {% if interface_data.enabled == True %} - \"is up, line protocol is up\" {% elif interface_data.enabled == False %} - \"is down, admin down\" {% endif %} name: check interface {{ interface_name }} status {% endfor %} Calling salt['nr.netbox']('get_interfaces', 'ceos1') inside of the template gives us access to device interfaces data following with for loop that renders individual interface tests. Running above tests suite will produce these results: [root@salt-master /]# salt nrp1 nr.test suite=\"salt://tests/test_suite_ceos1_netbox.j2\" FB=ceos1 table=brief nrp1: +----+--------+----------------------------------+----------+-----------+ | | host | name | result | exception | +====+========+==================================+==========+===========+ | 0 | ceos1 | check interface Loopback0 status | PASS | | +----+--------+----------------------------------+----------+-----------+ | 1 | ceos1 | check interface Ethernet1 status | PASS | | +----+--------+----------------------------------+----------+-----------+ There is also an option to do dry_run to produce tests suite content only without running the actual tests: [root@salt-master /]# salt nrp1 nr.test suite=\"salt://tests/test_suite_ceos1_netbox.j2\" FB=ceos1 dry_run=True --out=yaml nrp1: ceos1: - name: check interface Loopback0 status pattern: - 1500 - RID and MGMT loopback - is up, line protocol is up task: show interface Loopback0 test: contains_lines - name: check interface Ethernet1 status pattern: - 9200 - East-West Campus uplink - is up, line protocol is up task: show interface Ethernet1 test: contains_lines [root@salt-master /]# Conclusion # Running data driven tests on devices show commands output is not an easy task, Nornir TestsProcessor, SaltStack Salt-Nornir Proxy Minion and Netbox all combined or on its own, provide a great deal of flexibility and capabilities to successfully execute in that direction. Thank you for reading to the end, all the best you and your networks.","title":"Templating Network Tests"},{"location":"2023-02-05-templating-network-tests/#introduction","text":"Templating network devices configuration is a very common approach nowadays, network testing however, is rarely ( if at all) automated. Jinja2 comes to mind when somebody mentions network templates, YAML also pops up as a common way of expressing network related data. SaltStack, Ansible, Nornir and others provide native support for workflows and payload templating using popular templating languages, this however rarely used to automate network tests. The difficulty of doing network testing is due to the lack of structured data that can be easily extracted from network devices. As a result, one of common ways of dealing with network testing is to use show commands output to interpret devices state and operator using that output coupled with expert knowledge decides if system is in a desired state or needs remediation. Luckily, if system created that can use plain text to encode tests content to carry on with testing, that system is very close to templating those steps using data driven approach.","title":"Introduction"},{"location":"2023-02-05-templating-network-tests/#meet-nornir-testsprocessor","text":"In one of my previous blog posts I had a chance to write about the fact that network tests can be classified based one the scope as local (unit), adjacent (integration) and network (system) tests, the focus of this write up is mainly on local and adjacent types of scenarios. This is due to the fact that TestProcessor was created to deal with data produced by a single device only. Original vision behind TestsProcessor was to take a piece of static YAML: - name : Software version test task : show version test : contains pattern : \"17.3.1\" err_msg : Software version is wrong - name : Logging configuration check task : \"show run | inc logging\" test : contains pattern : 10.0.0.1 err_msg : Logging configuration is wrong collect output from network devices and emit tests results: +----+--------+-----------------------------+----------+---------------------------+ | | host | name | result | exception | +====+========+=============================+==========+===========================+ | 0 | R1 | Software version test | FAIL | Software version is wrong | +----+--------+-----------------------------+----------+---------------------------+ | 1 | R1 | Logging configuration check | PASS | | +----+--------+-----------------------------+----------+---------------------------+ Another networking industry common approach is to take data like: HostName: switch1 Vlans: - VlanId: 10 VlanName: MGMT - VlanId: 20 VlanName: ACCESS couple with Jinja2 template: hostname {{ HostName }} ! {% for Vlan in Vlans -%} vlan {{ Vlan['VlanId'] }} name {{ Vlan['VlanName'] }} ! {% endfor -%} and produce network device configuration: hostname switch1 ! vlan 10 name MGMT ! vlan 20 name ACCESS Combining above two approaches lead to conclusion that it should be possible to make TestsProcessor tests suites dynamic, driven entirely by host data. For example, if we have these two Nornir hosts: hosts: jundevice-1: hostname: 10.0.0.1 platform: juniper_junos groups: [\"auth\"] data: software_version: 18.1R3-S9 xrdevice-1: hostname: 10.0.0.2 platform: cisco_xr groups: [\"auth\"] data: software_version: 7.5.2 groups: auth: username: nornir password: nornir it is possible to write Jinja2 template like this: - name: Software version test task: show version test: contains pattern: {{ host.software_version }} err_msg: Software version is wrong producing host specific tests to run to validate device software version. Above idea was implemented in Nornir-Salt starting with release 0.16.0","title":"Meet Nornir TestsProcessor"},{"location":"2023-02-05-templating-network-tests/#scaling-up-using-salt-nornir","text":"Using Nornir to run tests for a handful (hundreds) of devices is great, but doing same for bigger (much bigger) number of devices requires non trivial engineering. Salt-Nornir helps to scale network management using Nornir based proxy minions, each handling multiple devices. Hence, network testing also can be scaled out using Salt-Nornir proxy minions. For example, given the test suite on master at /etc/salt/master/tests/testsuite-1.txt : - task: \"show version\" test: contains pattern: \"{{ host.software_version }}\" name: check ceos version {% for interface in host.interfaces %} - task: \"show interface {{ interface.name }}\" test: contains_lines pattern: - {{ interface.admin_status }} - {{ interface.line_status }} - {{ interface.mtu }} - {{ interface.description }} name: check interface {{ interface.name }} status {% endfor %} coupled with this proxy minion pillar inventory: hosts: ceos1: hostname: 10.0.1.4 platform: arista_eos username: nornir password: nornir data: software_version: cEOS interfaces: - name: Ethernet1 admin_status: is up description: East-West Campus uplink line_status: line protocol is up mtu: IP MTU 9200 - name: Loopback0 admin_status: is up description: RID and MGMT loopback line_status: line protocol is up mtu: IP MTU 1500 tests suite can be run using command: [root@salt-master /]# salt nrp1 nr.test suite=\"salt://tests/testsuite-1.txt\" table=brief nrp1: +----+--------+----------------------------------+----------+-------------+ | | host | name | result | exception | +====+========+==================================+==========+=============+ | 0 | ceos1 | check ceos version | PASS | | +----+--------+----------------------------------+----------+-------------+ | 1 | ceos1 | check interface Ethernet1 status | PASS | | +----+--------+----------------------------------+----------+-------------+ | 2 | ceos1 | check interface Loopback1 status | PASS | | +----+--------+----------------------------------+----------+-------------+ [root@salt-master /]# As you can see, tests content was dynamically rendered according to data stored in host's inventory. Combine this with SaltStack reach data sourcing capabilities and We have a workable solution to test our networks.","title":"Scaling Up using Salt-Nornir"},{"location":"2023-02-05-templating-network-tests/#adding-netbox-into-the-mix","text":"Netbox is a DCIM/IPAM software to model and document modern networks. Salt-Nornir comes with Netbox Pillar and Netbox Execution Modules, combined, they are capable of sourcing any data from Netbox over REST or GraphQL API right from your templates. Netbox allows to model device interfaces. Example of interfaces modeled in Netbox for ceos1 device: Using Salt-Nornir execution module Netbox get_interfaces functions we can retrieve device interfaces data from Netbox: [root@salt-master /]# salt nrp1 nr.netbox get_interfaces device_name=ceos1 --out=yaml nrp1: Ethernet1: bridge: null bridge_interfaces: [] child_interfaces: [] custom_fields: {} description: East-West Campus uplink duplex: FULL enabled: true last_updated: '2022-12-30T11:21:59.922564+00:00' mac_address: null member_interfaces: [] mode: null mtu: 9200 parent: null speed: null tagged_vlans: [] tags: [] untagged_vlan: null vrf: null wwn: null Loopback0: bridge: null bridge_interfaces: [] child_interfaces: [] custom_fields: {} description: RID and MGMT loopback duplex: null enabled: true last_updated: '2022-12-30T11:22:32.225050+00:00' mac_address: null member_interfaces: [] mode: null mtu: 1500 parent: null speed: null tagged_vlans: [] tags: [] untagged_vlan: null vrf: null wwn: null SaltStack conveniently allows to call execution module functions from within the Jinja2 templates, enabling us to source any data directly during template rendering process. Let use that in this template producing tests suite accordingly: {% set interfaces = salt['nr.netbox']('get_interfaces', 'ceos1') %} {% for interface_name, interface_data in interfaces.items() %} - task: \"show interface {{ interface_name }}\" test: contains_lines pattern: - {{ interface_data.mtu }} - {{ interface_data.description }} {% if interface_data.enabled == True %} - \"is up, line protocol is up\" {% elif interface_data.enabled == False %} - \"is down, admin down\" {% endif %} name: check interface {{ interface_name }} status {% endfor %} Calling salt['nr.netbox']('get_interfaces', 'ceos1') inside of the template gives us access to device interfaces data following with for loop that renders individual interface tests. Running above tests suite will produce these results: [root@salt-master /]# salt nrp1 nr.test suite=\"salt://tests/test_suite_ceos1_netbox.j2\" FB=ceos1 table=brief nrp1: +----+--------+----------------------------------+----------+-----------+ | | host | name | result | exception | +====+========+==================================+==========+===========+ | 0 | ceos1 | check interface Loopback0 status | PASS | | +----+--------+----------------------------------+----------+-----------+ | 1 | ceos1 | check interface Ethernet1 status | PASS | | +----+--------+----------------------------------+----------+-----------+ There is also an option to do dry_run to produce tests suite content only without running the actual tests: [root@salt-master /]# salt nrp1 nr.test suite=\"salt://tests/test_suite_ceos1_netbox.j2\" FB=ceos1 dry_run=True --out=yaml nrp1: ceos1: - name: check interface Loopback0 status pattern: - 1500 - RID and MGMT loopback - is up, line protocol is up task: show interface Loopback0 test: contains_lines - name: check interface Ethernet1 status pattern: - 9200 - East-West Campus uplink - is up, line protocol is up task: show interface Ethernet1 test: contains_lines [root@salt-master /]#","title":"Adding Netbox into the mix"},{"location":"2023-02-05-templating-network-tests/#conclusion","text":"Running data driven tests on devices show commands output is not an easy task, Nornir TestsProcessor, SaltStack Salt-Nornir Proxy Minion and Netbox all combined or on its own, provide a great deal of flexibility and capabilities to successfully execute in that direction. Thank you for reading to the end, all the best you and your networks.","title":"Conclusion"},{"location":"posts/","text":"5 Efficient Ways to Collect Show Commands Output From Network Devices # Continue Reading ... Templating Network Tests # Continue Reading ...","title":"Blog Posts"},{"location":"posts/#5-efficient-ways-to-collect-show-commands-output-from-network-devices","text":"Continue Reading ...","title":"5 Efficient Ways to Collect Show Commands Output From Network Devices"},{"location":"posts/#templating-network-tests","text":"Continue Reading ...","title":"Templating Network Tests"}]}